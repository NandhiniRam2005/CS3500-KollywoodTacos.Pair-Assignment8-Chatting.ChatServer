@*
	// <copyright file="NetworkConnection.cs" company="UofU-CS3500">
	// Copyright (c) 2024 UofU-CS3500. All rights reserved.
	//
</copyright>

   /// <summary>
   	/// Author:    Joel Rodriguez,  Nandhini Ramanathan, and Professor Jim.
   	/// Partner:   None
   	/// Date:      November 22, 2024
   	/// Course:    CS 3500, University of Utah, School of Computing
   	/// Copyright: CS 3500 and [Joel Rodriguez and Nandhini Ramanathan] - This work may no
   	///            be copied for use in Academic Coursework.
   	///
   	/// I, Joel Rodriguez and Nandhini Ramanathan, certify that I wrote this code from scratch and
   	/// did not copy it in part or whole from another source.  All
   	/// references used in the completion of the assignments are cited
   	/// in my README file.
   	///
   	/// File Contents
   	///     This file renders the Snake game, manages the game state,
    ///     and interacts with the other classes for data retrieval and updates.
   </summary>
*@

@page "/snake"
@rendermode InteractiveServer
@implements IDisposable
@inject IJSRuntime JS  // <remarks> Allows the "communication"/use of javascriptt </remarks>

@using Blazor.Extensions
@using Blazor.Extensions.Canvas
@using Blazor.Extensions.Canvas.Canvas2D
@using System.Drawing
@using CS3500.Networking
@using System.Diagnostics
@using Microsoft.Extensions.Logging.Abstractions
@using System.Net.Sockets
@using System.Text.Json
@using Snake.Client.Models
@using Snake.Client.Controller

@inject IJSRuntime JsRuntime;
@inject ILogger<Program> Logger;

<PageTitle> SnakeGame </PageTitle>

<h1>Snake Game</h1>
<p> Play Snake! </p>


<div>
	<label for="nameInput">Name: </label>
	<input id="connectedInput" @bind="Name" readonly="@isConnected" />
	<label for="ServerAddress">Server Address:</label>
	<input id="connectedInput" @bind="ServerAddress" readonly="@isConnected" />
	<label for="Port">Port:</label>
	<input id="connectedInput" type="number" @bind="Port" readonly="@isConnected" />

	<button disabled="@isConnected" class="btn btn-primary" @onclick="Connect">Connect</button>

</div>
<label for="Network Status" id="status">Connection Status: </label>
<label for="Network Status" id="status">@networkStatus</label>
<div id="myCanvas">
	<BECanvas Width="1000" Height="1000" @ref="canvasReference" />
</div>
<img @ref="backgroundImage" id="backgroundImage" src="images/background.jpg" alt="image" style="display:none;" />
<img @ref="wallImage" id="wallImage" src="images/cobblestone.jpg" alt="image" style="display:none;" />
<img @ref="grassTerrain" id="grassTerrain" src="images/grassterrain.jpg" alt="image" style="display:none;" />


@code
{
	/// <summary>
	/// Represents a reference to the canvas element for drawing.
	/// </summary>
	private BECanvasComponent canvasReference = null!;

	/// <summary>
	/// Represents the 2D drawing context of the canvas.
	/// </summary>
	private Canvas2DContext context = null!;

	// GUI Model here:

	/// <summary>
	/// The width and height of the view used for rendering.
	/// </summary>
	private int ViewWidth = 1000, ViewHeight = 1000;

	/// <summary>
	/// The start time of the application.
	/// </summary>
	private DateTime StartTime = DateTime.Now;

	/// <summary>
	/// Tracks the number of frames rendered for the GUI.
	/// </summary>
	private int frameNumberGUI = 0;

	/// <summary>
	/// Stores the error message to be displayed.
	/// </summary>
	private string errorMessage = string.Empty;

	/// <summary>
	/// Represents the reference to the background image element.
	/// </summary>
	private ElementReference backgroundImage;

	/// <summary>
	/// Represents the reference to the wall image element.
	/// </summary>
	private ElementReference wallImage;

	/// <summary>
	/// Represents the reference to the grass terrain image element.
	/// </summary>
	private ElementReference grassTerrain;
	public bool isConnected { get; set; } = false;

	/// <summary>
	/// Represents the current state of the game world, including walls, snakes, and power-ups.
	/// </summary>
	private World world = new World(new Dictionary<int, Wall>(), new Dictionary<int, Snake>(), new Dictionary<int, Powerup>(), 0, 0, 0);

	// Controller Model here:

	/// <summary>
	/// Reference to the JavaScript module.
	/// </summary>
	private IJSObjectReference _jsModule = null!;

	// Network model here:

	/// <summary>
	/// Manages the network connection and communication.
	/// </summary>
	private NetworkController networkController = new NetworkController();

	/// <summary>
	/// Indicates the current network status.
	/// </summary>
	private string networkStatus  { get; set; } = "Waiting For You to Connect";

	/// <summary>
	/// Tracks the number of frames processed in the network.
	/// </summary>
	private int frameNumberNetwork = 0;

	/// <summary>
	/// Tracks the time when the connection was established.
	/// </summary>
	private DateTime ConnectTime = DateTime.Now;

	/// <summary>
	/// Backing store for the player's name.
	/// </summary>
	private string nameBackingStore = "ImASnek";

	/// <summary>
	/// Represents the player's name which is checked for validity.
	/// </summary>
	private string Name
	{
		get
		{
			return nameBackingStore;
		}
		set
		{
			string name = value;
			if (name.Length > 16 || name.Length == 0)
			{
				ShowInvalidNameMessage();
			}
			else
			{
				nameBackingStore = name;

			}
			StateHasChanged();
		}
	}

	/// <summary>
	/// Backing store for the server address.
	/// </summary>
	private string serverAddressBacking = "localhost";

	/// <summary>
	/// Represents the server address with is checked for validity.
	/// </summary>
	private string ServerAddress
	{
		get
		{
			return serverAddressBacking;
		}
		set
		{
			string newAddress = value;
			if (newAddress.Length == 0)
			{
				ShowInvalidServerAddressMessage();
			}
			else
			{
				serverAddressBacking = newAddress;
			}
		}
	}

	/// <summary>
	/// Represents the port number for the server connection.
	/// </summary>
	private int Port { get; set; } = 11_000;

	/// <summary>
	///   First step in the Blazor Page Life Cycle.  In some circumstances
	///   you would load data here.  We do not need to.
	/// </summary>
	protected override void OnInitialized()
	{

	}

	/// <summary>
	///   The first time we start up, we load our JavaScript and start the animation
	///   process.
	/// </summary>
	/// <param name="firstRender">Indicates whether this is the first render.</param>
	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		if (firstRender)
		{
			_jsModule = await JsRuntime.InvokeAsync<IJSObjectReference>("import", "./Pages/SnakePage.razor.js");
			context = await canvasReference.CreateCanvas2DAsync();

			await _jsModule.InvokeVoidAsync("initJS", DotNetObjectReference.Create(this));
			await _jsModule.InvokeVoidAsync("ToggleAnimation", true);
		}
	}

	/// <summary>
	///   Attempt to connect to the server and begin the drawing process.
	/// </summary>
	private void Connect()
	{
		Logger.LogInformation("Connecting!");
		if (!networkController.IsServerConnected)
		{


			networkController.HandleNetwork(world, ServerAddress, Port, Name);
			if (networkController.IsServerConnected)
			{
				isConnected = true;
				networkStatus = "Connected!";
			}
			else
			{
				ShowServerConnectionFailedMessage();
				networkStatus = "Failed to connect to server. " + networkController.ErrorMessage;
			}

		}
		if (networkController.IsServerConnected)
		{
			isConnected = true;
		}

	}

	/// <summary>
	///   Draws the game , including snakes, walls, and power-ups.
	/// </summary>
	/// <param name="timeStamp">
	///   Tells you how many milliseconds have
	///   elapsed sense the web page was loaded.
	/// </param>
	[JSInvokable]
	public async void Draw(double timeStamp = 0)
	{
		// Calculations made for the Heads Up display
		frameNumberGUI++;

		double fps = frameNumberGUI / (double)(DateTime.Now - StartTime).TotalSeconds;
		double nps = frameNumberNetwork / (double)(DateTime.Now - ConnectTime).TotalSeconds;
		int timeInSeconds = (int)(timeStamp / 1000);

		World worldCopy;
		lock (world)
		{
			worldCopy = new World(world.Walls, world.Snakes, world.Powerups, world.Width, world.Height, world.WorldID);
		}
		try
		{
			// Group all the draw commands into one large single draw.
			int headX = worldCopy.Snakes[worldCopy.WorldID].body[^1].X;
			int headY = worldCopy.Snakes[worldCopy.WorldID].body[^1].Y;

			await context.BeginBatchAsync();

			// Clear the canvas for the new frame
			await context.ClearRectAsync(0, 0, ViewWidth, ViewHeight);
			await context.SetFillStyleAsync("lightblue");
			await context.FillRectAsync(0, 0, ViewWidth, ViewHeight);

			// clip the view so that objects drawn outside the canvas will not be shown
			await context.BeginPathAsync();
			await context.RectAsync(0, 0, ViewWidth, ViewHeight);
			await context.ClipAsync();

			// Because we are modifying the transformation matrix, we need to save it so we can restore it at the end
			await context.SaveAsync();

			// Calculate offsets from worldCopy space
			double offsetX = -(headX - (ViewWidth / 2));
			double offsetY = -(headY - (ViewHeight / 2));

			// Center on origin, move to center of view port
			await context.TranslateAsync(ViewWidth / 2, ViewHeight / 2);
			await context.TranslateAsync(-headX, -headY);

			// Draw the background:
			await context.DrawImageAsync(grassTerrain, -worldCopy.Width / 2, -worldCopy.Height / 2, worldCopy.Width, worldCopy.Height);

			// Draw all the walls in a loop:
			foreach (Wall wall in worldCopy.Walls.Values)
			{
				int bottomLeftCornerX = Math.Min(wall.p1.X, wall.p2.X);
				int bottomLeftCornerY = Math.Min(wall.p1.Y, wall.p2.Y);

				int wallWidth = Math.Abs(wall.p1.X - wall.p2.X) + 50;
				int wallHeight = Math.Abs(wall.p1.Y - wall.p2.Y) + 50;

				for (int xChange = bottomLeftCornerX - 25; xChange < bottomLeftCornerX - 25  + wallWidth; xChange += 50)
				{
					for (int yChange = bottomLeftCornerY -25; yChange < bottomLeftCornerY  - 25 + wallHeight; yChange += 50)
					{
						await context.DrawImageAsync(wallImage, xChange, yChange, 50, 50);
					}
				}
				// await context.DrawImageAsync(wallImage, bottomLeftCornerX - 25, bottomLeftCornerY - 25, wallWidth, wallHeight);
			}

			// Draw all the snakes in a loop with different colors for different clients:
			foreach (Snake snake in worldCopy.Snakes.Values)
			{
				if (snake.died || !snake.alive)
				{
					await context.SetFillStyleAsync("red");
				}
				else
				{
					switch (snake.snake % 8)
					{
						case 0:
							await context.SetFillStyleAsync("darkblue");
							await context.SetStrokeStyleAsync("darkred");
							break;
						case 1:
							await context.SetFillStyleAsync("orange");
							await context.SetStrokeStyleAsync("lightgreen");
							break;
						case 2:
							await context.SetFillStyleAsync("black");
							await context.SetStrokeStyleAsync("darkgrey");
							break;
						case 3:
							await context.SetFillStyleAsync("magenta");
							await context.SetStrokeStyleAsync("cyan");
							break;
						case 4:
							await context.SetFillStyleAsync("darkred");
							await context.SetStrokeStyleAsync("blue");
							break;
						case 5:
							await context.SetFillStyleAsync("pink");
							await context.SetStrokeStyleAsync("purple");
							break;
						case 6:
							await context.SetFillStyleAsync("purple");
							await context.SetStrokeStyleAsync("pink");
							break;
						case 7:
							await context.SetFillStyleAsync("cyan");
							await context.SetStrokeStyleAsync("magenta");
							break;
						default:
							break;
					}
				}

				// Draw each part/segment of the snake's body.
				for (int i = 0; i < snake.body.Count - 1; i++)
				{

					int bottomLeftCornerX = Math.Min(snake.body[i].X, snake.body[i + 1].X);
					int bottomLeftCornerY = Math.Min(snake.body[i].Y, snake.body[i + 1].Y);

					int snakePartWidth = Math.Abs(snake.body[i].X - snake.body[i + 1].X) + 10;
					int snakePartHeight = Math.Abs(snake.body[i].Y - snake.body[i + 1].Y) + 10;

					await context.FillRectAsync(bottomLeftCornerX - 5, bottomLeftCornerY - 5, snakePartWidth, snakePartHeight);
					await context.StrokeRectAsync(bottomLeftCornerX - 5, bottomLeftCornerY - 5, snakePartWidth, snakePartHeight);
				}

				// Display each snake's name and score, orientation is determined by which direction snake is going.
				int currentSnakeHeadX = 0;
				int currentSnakeHeadY = 0;
				foreach (Snake currentSnake in worldCopy.Snakes.Values)
				{
					currentSnakeHeadX = worldCopy.Snakes[currentSnake.snake].body[^1].X;
					currentSnakeHeadY = worldCopy.Snakes[currentSnake.snake].body[^1].Y;
					await context.SetFontAsync("20px Arial");
					await context.SetFillStyleAsync("white");
					switch (currentSnake.dir.X)
					{
						case 1:
							await context.FillTextAsync($"{currentSnake.name} : {currentSnake.score}", currentSnakeHeadX - (currentSnake.name.Length * 8), currentSnakeHeadY - (currentSnake.name.Length * 2));
							break;
						case -1:
							await context.FillTextAsync($"{currentSnake.name} : {currentSnake.score}", currentSnakeHeadX - (currentSnake.name.Length * 2), currentSnakeHeadY - (currentSnake.name.Length * 2));
							break;
						default:
							switch (currentSnake.dir.Y)
							{
								case 1:
									await context.FillTextAsync($"{currentSnake.name} : {currentSnake.score}", currentSnakeHeadX - (currentSnake.name.Length * 6), currentSnakeHeadY - (currentSnake.name.Length * 3));
									break;
								case -1:
									await context.FillTextAsync($"{currentSnake.name} : {currentSnake.score}", currentSnakeHeadX - (currentSnake.name.Length * 6), currentSnakeHeadY + (currentSnake.name.Length * 3));
									break;
								default:
									break;
							}
							break;

					}
				}
			}

			// Draw each power up in a loop:
			foreach (Powerup powerup in worldCopy.Powerups.Values)
			{
				await context.BeginPathAsync();
				await context.SetFillStyleAsync("red");
				await context.SetStrokeStyleAsync("brown");
				await context.SetLineWidthAsync(6);
				await context.ArcAsync(powerup.loc.X, powerup.loc.Y, 8, 0, 2 * Math.PI);
				await context.FillAsync();
				await context.StrokeAsync();
			}


			await context.RestoreAsync();

			// Draw Heads Up Display - done last so it is on top
			await context.SetFontAsync("30px Arial");
			await context.SetFillStyleAsync("white");
			await context.FillTextAsync($"FPS: {fps:F1}", 400, 30);
			string playerNamesAndScores = string.Empty;
			foreach (Snake snakePlayer in worldCopy.Snakes.Values)
			{
				playerNamesAndScores = playerNamesAndScores + snakePlayer.name + " Score: " + snakePlayer.score + "\n";
			}

			float x = 10;
			float y = 30;
			float lineHeight = 30;

			foreach (string line in playerNamesAndScores.Split('\n'))
			{
				await context.FillTextAsync(line, x, y);
				y += lineHeight;
			}

			await context.FillTextAsync($"Elapsed: {timeInSeconds:F0} seconds", 550, 30);

			await context.EndBatchAsync();
		}
		catch
		{
		}
	}

	/// <summary>
	///   <para>
	///     This method is called from the JavaScript side of the
	///     browser.
	///   </para>
	/// </summary>
	/// <param name="width">The new view width.</param>
	/// <param name="height">The new view height.</param>
	[JSInvokable]
	public void ResizeInBlazor(int width, int height)
	{
		Logger.LogTrace("Resizing the web page. {width} {height}", width, height);
		ViewWidth = Math.Min(Math.Max(100, width), 1000);
		ViewHeight = Math.Min(Math.Max(100, height), 1000);
	}

	/// <summary>
	///   Called by the system when the page is navigated away from.
	/// </summary>
	public void Dispose()
	{
		_jsModule.InvokeVoidAsync("ToggleAnimation", false);
	}

	/// <summary>
	/// Handles key press events received.
	/// </summary>
	/// <param name="keyEvent">The key event representing the key pressed by the user.</param>
	[JSInvokable]
	public void HandleKeyPress(String keyEvent)
	{
		networkController.HandleKeyPress(keyEvent);
	}
	/// <summary>
	///  Shows invalid message when name change is invalid.
	/// </summary>
	private async void ShowInvalidNameMessage()
	{
		// We need this helper method to be async which is why we can't directly have this line of code in the NameWidget setter.
		await JS.InvokeVoidAsync("alert", "Name must be less than 16 charchters in length and at least 1 character long. Try again.");

	}
	/// <summary>
	///  Shows invalid message when ServerSnake Address change is invalid.
	/// </summary>
	private async void ShowInvalidServerAddressMessage()
	{
		// We need this helper method to be async which is why we can't directly have this line of code in the ServerAddressWidget setter.
		await JS.InvokeVoidAsync("alert", "ServerSnake address must be of at least length one.");

	}
	/// <summary>
	///  Shows invalid message when server connection fails.
	/// </summary>
	private async void ShowServerConnectionFailedMessage()
	{
		// We need this helper method to be async which is why we can't directly have this line of code in the Connect. We were advised not to make a method async for one line of code.
		await JS.InvokeVoidAsync("alert", "ServerSnake connection failed please try again, please make sure your port and server address are correct.");
	}

	/// <summary>
	/// This method disconnects the server and removes the user's snake from the game world.
	/// </remarks>
	[JSInvokable]
	public void HandleUserLeaving()
	{
		networkController.ServerSnake.Disconnect();
		networkController.ServerSnake = new(NullLogger.Instance);
		lock (world)
		{
			world.Snakes.Remove(world.WorldID);
		}
	}
}
