@page "/snake"
@*
    The following line forces the code to run on the webserver.

    Notice that we run this code on the web server so that
    it has access to the network. If you run this as web assembly
    (i.e., on the browser) it would not be able to connect to
    the snake server using our networking code.
*@
@rendermode InteractiveServer
@implements IDisposable
@inject IJSRuntime JS  // <remarks> Allows the "communication"/use of javascriptt </remarks>

@using Blazor.Extensions
@using Blazor.Extensions.Canvas
@using Blazor.Extensions.Canvas.Canvas2D
@using System.Drawing
@using CS3500.Networking
@using System.Diagnostics
@using Microsoft.Extensions.Logging.Abstractions
@using System.Net.Sockets
@using System.Text.Json
@using Snake.Client.Models
@using Snake.Client.Controller

@inject IJSRuntime JsRuntime;
@inject ILogger<Program> Logger;

<PageTitle> SnakeGame </PageTitle>

<h1>Snake Game</h1>
<p> Play Snake! </p>

@if (!networkController.server.IsConnected)
{
	<div>
	<label for="nameInput">Player Name:</label>
	<input id="nameInput" @bind="Name" />
	<label for="ServerAddress">Server Address:</label>
	<input id="ServerAddress" @bind="ServerAddress" />
	<label for="Port">Port:</label>
	<input id="Port" type="number" @bind="Port" />

	<button class="btn btn-primary" @onclick="Connect">Connect</button>
	</div>
	<label for="ConnectionStatus">ConnectionStatus: </label>
	<input id="connectionStatus" @bind="networkController.networkStatus" readonly />
}
else
{
	<div>
	<label for="nameInput">Name: </label>
	<input id="connectedInput" @bind="Name" readonly />
	<label for="ServerAddress">Server Address:</label>
	<input id="connectedInput" @bind="ServerAddress" readonly />
	<label for="Port">Port:</label>
	<input id="connectedInput" type="number" @bind="Port" readonly />

	<button disabled class="btn btn-primary" @onclick="Connect">Connect</button>
	</div>
	<label for="ConnectionStatus">ConnectionStatus: </label>
	<input id="connectionStatus" @bind="networkController.networkStatus" readonly />
}

<div id="myCanvas">
	<BECanvas Width="1000" Height="1000" @ref="canvasReference" />
</div>
<img @ref="backgroundImage" id="backgroundImage" src="images/background.jpg" alt="image" style="display:none;" />
<img @ref="wallImage" id="wallImage" src="images/cobblestone.jpg" alt="image" style="display:none;" />
<img @ref="grassTerrain" id="grassTerrain" src="images/grassterrain.jpg" alt="image" style="display:none;" />


@code
{
	// Drawing/Canvas variables here.
	private BECanvasComponent canvasReference = null!;
	private Canvas2DContext context = null!;

	// GUI Model here:
	private int ViewWidth = 1000, ViewHeight = 1000;
	private DateTime StartTime = DateTime.Now;
	private int frameNumberGUI = 0;
	private string errorMessage = string.Empty;
	private ElementReference backgroundImage;
	private ElementReference wallImage;
	private ElementReference grassTerrain;

	// WORLD Model here:
	private World world = new World(new Dictionary<int, Wall>(), new Dictionary<int, Snake>(), new Dictionary<int, Powerup>(), 0,0,0);
	private int snakeID;

	// Controller Model here:
	private IJSObjectReference _jsModule = null!;

	// Network model
	private NetworkController networkController = new NetworkController();
	// private NetworkConnection server = new(NullLogger.Instance);
	private string networkStatus = "Waiting For You to Connect";
	private int frameNumberNetwork = 0;
	private DateTime ConnectTime = DateTime.Now;

	private String snakeDirection = "Up";


	private string nameBackingStore = "defaultPlayer";
	private string Name
	{
		get
		{
			return nameBackingStore;
		}
		set
		{
			string name = value;
			if (name.Length > 16 || name.Length == 0)
			{
				ShowInvalidNameMessage();
			}
			else
			{
				nameBackingStore = name;

			}
			StateHasChanged();
		}
	}
	private string serverAddressBacking = "localhost";
	private string ServerAddress
	{
		get
		{
			return serverAddressBacking;
		}
		set
		{
			string newAddress = value;
			if (newAddress.Length == 0)
			{
				ShowInvalidServerAddressMessage();
			}
			else
			{
				serverAddressBacking = newAddress;
			}
		}
	}

	private int Port { get; set; } = 11_000;

	/// <summary>
	///   First step in the Blazor Page Life Cycle.  In some circumstances
	///   you would load data here.  We do not need to.
	/// </summary>
	protected override void OnInitialized()
	{

	}

	/// <summary>
	///   The first time we start up, we load our JavaScript and start the animation
	///   process.
	/// </summary>
	/// <param name="firstRender"></param>
	/// <returns></returns>
	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		if (firstRender)
		{
			_jsModule = await JsRuntime.InvokeAsync<IJSObjectReference>("import", "./Pages/SnakePage.razor.js");
			context = await canvasReference.CreateCanvas2DAsync();

			await _jsModule.InvokeVoidAsync("initJS", DotNetObjectReference.Create(this));
			await _jsModule.InvokeVoidAsync("ToggleAnimation", true);
		}
	}

	/// <summary>
	///   Attempt to connect to the server and begin the drawing process.
	/// </summary>
	private void Connect()
	{
		Logger.LogInformation("Connecting!");
		StateHasChanged();
		networkController.HandleNetwork(world, ServerAddress, Port, Name);
		StateHasChanged();

	}

	/// <summary>
	///   Draw the world
	/// </summary>
	/// <param name="timeStamp">
	///   Tells you how many milliseconds have
	///   elapsed sense the web page was loaded.
	/// </param>
	[JSInvokable]
	public async void Draw(double timeStamp = 0)
	{
		frameNumberGUI++;

		double fps = frameNumberGUI / (double)(DateTime.Now - StartTime).TotalSeconds;
		double nps = frameNumberNetwork / (double)(DateTime.Now - ConnectTime).TotalSeconds;
		int timeInSeconds = (int)(timeStamp / 1000);
		World worldCopy;
		lock (world)
		{
			worldCopy = new World(world.Walls, world.Snakes, world.Powerups, world.Width, world.Height, world.WorldID);
		}
		try
		{
			

			// Group all the draw commands into one large single draw.
			int headX = worldCopy.Snakes[worldCopy.WorldID].body[^1].X;
			int headY = worldCopy.Snakes[worldCopy.WorldID].body[^1].Y;

			await context.BeginBatchAsync();

			//DRAW BG BEFORE APPARNTLY GOTTA CLEAR STUFF EVERY FRAME :-\
			await context.ClearRectAsync(0, 0, ViewWidth, ViewHeight);
			await context.SetFillStyleAsync("lightblue");
			await context.FillRectAsync(0, 0, ViewWidth, ViewHeight);

			// clip the view so that objects drawn outside the canvas will not be shown
			await context.BeginPathAsync();
			await context.RectAsync(0, 0, ViewWidth, ViewHeight);
			await context.ClipAsync();

			// Because we are modifying the transformation matrix, we need to save it so we can restore it at the end
			await context.SaveAsync();


			// Calculate offsets from worldCopy space
			double offsetX = -(headX - (ViewWidth / 2));
			double offsetY = -(headY - (ViewHeight / 2));

			// Center on origin, move to center of view port
			await context.TranslateAsync(ViewWidth / 2, ViewHeight / 2);
			await context.TranslateAsync(-headX, -headY); //???

			// Draw the background:
			await context.DrawImageAsync(grassTerrain, -worldCopy.Width / 2, -worldCopy.Height / 2, worldCopy.Width, worldCopy.Height);
			foreach (Wall wall in worldCopy.Walls.Values)
			{
				// Our walls are not drwing in gui coords they are drawing in worldCopy coords. And then also our walls can be possibly very huge or not exisiting.
				//await context.DrawImageAsync(wallImage, wall.p1.X, wall.p1.Y, wall.p1.X - wall.p2.X + 50, wall.p1.Y - wall.p2.Y + 50);

				int bottomLeftCornerX = Math.Min(wall.p1.X, wall.p2.X);
				int bottomLeftCornerY = Math.Min(wall.p1.Y, wall.p2.Y);

				int wallWidth = Math.Abs(wall.p1.X - wall.p2.X) + 50;
				int wallHeight = Math.Abs(wall.p1.Y - wall.p2.Y) + 50;

				await context.DrawImageAsync(wallImage, bottomLeftCornerX - 25, bottomLeftCornerY - 25, wallWidth, wallHeight);
			}

			foreach (Snake snake in worldCopy.Snakes.Values)
			{
				switch (snake.snake%8)
				{
					case 0:
						await context.SetFillStyleAsync("darkblue");
						await context.SetStrokeStyleAsync("darkred");
						break;
					case 1:
						await context.SetFillStyleAsync("orange");
						await context.SetStrokeStyleAsync("lightgreen");
						break;
					case 2:
						await context.SetFillStyleAsync("black");
						await context.SetStrokeStyleAsync("darkgrey");
						break; 
					case 3:
						await context.SetFillStyleAsync("magenta");
						await context.SetStrokeStyleAsync("cyan");
						break;
					case 4:
						await context.SetFillStyleAsync("red");
						await context.SetStrokeStyleAsync("blue");
						break;
					case 5:
						await context.SetFillStyleAsync("pink");
						await context.SetStrokeStyleAsync("purple");
						break;
					case 6:
						await context.SetFillStyleAsync("purple");
						await context.SetStrokeStyleAsync("pink");
						break;
					case 7:
						await context.SetFillStyleAsync("cyan");
						await context.SetStrokeStyleAsync("magenta");
						break;
					default:
						break;
				}

				// This is only drawing one section of the snake if it had "L" shapes it just does the first section
				// Snake isnt drawing in worldCopy coords and snake could be non existent or huge.

				// for (int i = 0; i < snake.body.Count / 2; i+=2)
				for (int i = 0; i < snake.body.Count - 1; i ++)
				{
					int bottomLeftCornerX = Math.Min(snake.body[i].X, snake.body[i + 1].X);
					int bottomLeftCornerY = Math.Min(snake.body[i].Y, snake.body[i + 1].Y);

					int snakePartWidth = Math.Abs(snake.body[i].X - snake.body[i + 1].X) + 10;
					int snakePartHeight = Math.Abs(snake.body[i].Y - snake.body[i + 1].Y) + 10;

					await context.FillRectAsync(bottomLeftCornerX - 5, bottomLeftCornerY - 5, snakePartWidth, snakePartHeight);
					await context.StrokeRectAsync(bottomLeftCornerX - 5, bottomLeftCornerY - 5, snakePartWidth, snakePartHeight);
					//await context.FillRectAsync(snake.body[i].X, snake.body[i].Y, snake.body[i+1].X - snake.body[i].X + 10, snake.body[i+1].Y - snake.body[i].Y);

				}
				int currentSnakeHeadX = 0;
				int currentSnakeHeadY = 0;
				foreach (Snake currentSnake in worldCopy.Snakes.Values) 
				{
					currentSnakeHeadX = worldCopy.Snakes[currentSnake.snake].body[^1].X;
					currentSnakeHeadY = worldCopy.Snakes[currentSnake.snake].body[^1].Y;
					await context.SetFontAsync("20px Arial");
					await context.SetFillStyleAsync("white");
					switch (currentSnake.dir.X)
					{
						case 1:
							await context.FillTextAsync($"{currentSnake.name} : {currentSnake.score}", currentSnakeHeadX - (currentSnake.name.Length * 8), currentSnakeHeadY - (currentSnake.name.Length * 2));
							break;
						case -1:
							await context.FillTextAsync($"{currentSnake.name} : {currentSnake.score}", currentSnakeHeadX - (currentSnake.name.Length * 2), currentSnakeHeadY - (currentSnake.name.Length * 2));
							break;
						default:
							switch (currentSnake.dir.Y)
							{
								case 1:
									await context.FillTextAsync($"{currentSnake.name} : {currentSnake.score}", currentSnakeHeadX - (currentSnake.name.Length * 6), currentSnakeHeadY - (currentSnake.name.Length * 3));
									break;
								case -1:
									await context.FillTextAsync($"{currentSnake.name} : {currentSnake.score}", currentSnakeHeadX - (currentSnake.name.Length * 6), currentSnakeHeadY + (currentSnake.name.Length * 3));
									break;
								default:
									break;
							}
							break;

					}
				}
			}
			foreach (Powerup powerup in worldCopy.Powerups.Values)
			{
				await context.BeginPathAsync();
				await context.SetFillStyleAsync("red");
				await context.SetStrokeStyleAsync("black");
				await context.ArcAsync(powerup.loc.X, powerup.loc.Y, 8, 0, 2 * Math.PI);
				await context.FillAsync();
				await context.StrokeAsync();
			}


			await context.RestoreAsync();


			// Draw Heads Up Display - do this last so it is on top
			await context.SetFontAsync("30px Arial");
			await context.SetFillStyleAsync("white");
			await context.FillTextAsync($"G-Frame: {frameNumberGUI}", 10, 30);
			await context.FillTextAsync($"N-Frame: {frameNumberNetwork}", 10, 60);
			await context.FillTextAsync($"FPS: {fps:F1}", 400, 30);
			string playerNamesAndScores = string.Empty;
			foreach (Snake snakePlayer in worldCopy.Snakes.Values)
			{
				playerNamesAndScores = playerNamesAndScores + snakePlayer.name + " Score: " + snakePlayer.score + "\n";
			}

			float x = 400;
			float y = 60; 
			float lineHeight = 30; 

			foreach (string line in playerNamesAndScores.Split('\n'))
			{
				await context.FillTextAsync(line, x, y);
				y += lineHeight; 
			}

			await context.FillTextAsync($"Elapsed: {timeInSeconds:F0} seconds", 550, 30);

			await context.EndBatchAsync();
		}
		catch (Exception e)
		{

		}
		Debug.WriteLine("Hello");
	}

	/// <summary>
	///   <para>
	///     This method is called from the JavaScript side of the
	///     browser.
	///   </para>
	///   <remarks>
	///      Must be PUBLIC for JavaScript to call!
	///   </remarks>
	/// </summary>
	/// <param name="width"></param>
	/// <param name="height"></param>
	[JSInvokable]
	public void ResizeInBlazor(int width, int height)
	{
		Logger.LogTrace("Resizing the web page. {width} {height}", width, height);
		ViewWidth = Math.Min(Math.Max(100, width), 1000);
		ViewHeight = Math.Min(Math.Max(100, height), 1000);
	}

	/// <summary>
	///   Called by the system when the page is navigated away from.
	///   Note: sometimes the debugger will create a "dummy" page when
	///   first navigated to, then dispose it, then create the actual page.
	///   You can ignore this behavior.
	/// </summary>
	public void Dispose()
	{
		_jsModule.InvokeVoidAsync("ToggleAnimation", false);
	}

	[JSInvokable]
	public void HandleKeyPress(String keyEvent)
	{
		networkController.HandleKeyPress(keyEvent);
	}
	/// <summary>
	///  Shows invalid message when name change is invalid
	/// </summary>
	private async void ShowInvalidNameMessage()
	{
		// We need this helper method to be async which is why we can't directly have this line of code in the NameWidget setter.
		await JS.InvokeVoidAsync("alert", "Name must be less than 16 charchters in length and at least 1 character long. Try again.");

	}
	/// <summary>
	///  Shows invalid message when Server Address change is invalid
	/// </summary>
	private async void ShowInvalidServerAddressMessage()
	{
		// We need this helper method to be async which is why we can't directly have this line of code in the NameWidget setter.
		await JS.InvokeVoidAsync("alert", "Server address must be of at least length one.");

	}
	[JSInvokable]
	public void HandleUserLeaving()
	{
		networkController.server.Disconnect();
		networkController.server = new(NullLogger.Instance);
		lock (world)
		{
			world.Snakes.Remove(world.WorldID);
		}
	}
}
